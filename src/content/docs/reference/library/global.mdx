---
title: Global Functions
description: Global functions and variables in SLua
sidebar:
    order: 0
---

import Attribution from '@components/Attribution.astro'


{/* Trying to order some useful groups towards the top */}
```slua
_G: table
_VERSION: string

-- \[Type Conversion](#type-conversion)
function type(obj: any): string
function typeof(obj: any): string
function tonumber(s: string, base: number?): number?
function tostring(obj: any): string
function tovector(s: string): vector
function toquaternion(s: string): quaternion
function torotation(s: string): quaternion
function touuid(s: string): uuid

-- \[Error Handling and Debugging](#error-handling-and-debugging)
function print(args: ...any)
function assert<T>(value: T, message: string?): T
function error(obj: any, level: number?)

-- \[Metatables](#metatables)
function getmetatable(obj: any): table?
function setmetatable(t: table, mt: table?)

-- \[Protected Calls](#protected-calls)
function pcall(f: function, args: ...any): (boolean, ...any)
function xpcall(f: function, e: function, args: ...any): (boolean, ...any)

-- \[Userdata Creation](#userdata-creation)
function newproxy(mt: boolean?): userdata

-- \[Module loading for bundlers](#module-loading-for-bundlers)
function dangerouslyexecuterequiredmodule(f: (...any) -> ...any): ...any

-- \[Raw Access](#raw-access)
function rawget<K, V>(t: { [K]: V }, k: K): V?
function rawset<K, V>(t: { [K] : V }, k: K, v: V)
function rawlen<K, V>(t: { [K]: V } | string): number
function rawequal(a: any, b: any): boolean

-- \[Iteration and Selection](#iteration-and-selection)
function next<K, V>(t: { [K]: V }, i: K?): (K, V)?
function select<T>(i: string, args: ...T): number
function select<T>(i: number, args: ...T): ...T
function ipairs(t: table): <iterator>
function pairs(t: table): <iterator>
```
:::tip
[Luau supports generalized iterators](https://luau.org/syntax#generalized-iteration) as the [modern and preferred method](https://luau.org/performance#optimized-table-iteration) for iterating over tables:
```slua
local arrayTable = {12, 34, 56}
for index, value in arrayTable do
	print(index, value)
end

local dictionaryTable = {a = 12, b = 34, c = 56}
for key, value in dictionaryTable do
	print(key, value)
end
```
:::
```slua
function unpack<V>(a: {V}, f: number?, t: number?): ...V
```
Equivalent to `table.unpack`


## Removed
```slua
function gcinfo(): number
function getfenv(target: (function | number)?): table
function setfenv(target: function | number, env: table)
```
:::danger
The above functions have been removed and are not available in Second Life SLua.
:::


## Full reference
Most library functions are part of a library like `math` or `table`. However there are some that don't have any namespacing and are just global functions, which is what this page documents.


### Type Conversion
```slua
function type(obj: any): string
```
Returns the type of object, which is one of `nil`, `boolean`, `number`, `vector`, `string`, `table`, `function`, `userdata`, `thread`, or `buffer`.

---

```slua
function typeof(obj: any): string
```
Returns the type of the object; for userdata objects that have a metatable with the `__type` field and are defined by the host (not `newproxy`), returns the value for that key. For custom userdata objects, such as ones returned by `newproxy`, this function returns `userdata` to make sure host-defined types can not be spoofed.

---


```slua
function tonumber(s: string, base: number?): number?
function tostring(obj: any): string
function tovector(s: string): vector3
function toquaternion(s: string): quaternion
function torotation(s: string): quaternion
function touuid(s: string): uuid
```
These functions allow you to convert between different types that SLua supports, typically from strings or into a string.



### Error Handling and Debugging
```slua
function print(args: ...any)
```
Prints all arguments into chat directly to the owner of object running the script. (Similar to `ll.OwnerSay`)

---

```slua
function assert<T>(value: T, message: string?): T
```
`assert` checks if the value is truthy; if it’s not (which means it’s `false` or `nil`), it raises an error. The error message can be customized with an optional parameter. Upon success the function returns the `value` argument.

---

```slua
function error(obj: any, level: number?)
```
`error` raises an error with the specified object. Note that errors don’t have to be strings, although they often are by convention; various error handling mechanisms like `pcall` preserve the error type. When `level` is specified, the error raised is turned into a string that contains call frame information for the caller at level `level`, where `1` refers to the function that called `error`. This can be useful to attribute the errors to callers, for example `error("Expected a valid object", 2)` highlights the caller of the function that called `error` instead of the function itself in the callstack.


### Metatables
```slua
function getmetatable(obj: any): table?
function setmetatable(t: table, mt: table?)
```
`getmetatable` returns the metatable for the specified object; when object is not a table or a userdata, the returned metatable is shared between all objects of the same type. Note that when metatable is protected (has a `__metatable` key), the value corresponding to that key is returned instead and may not be a table.

`setmetatable` changes metatable for the given table. Note that unlike `getmetatable`, this function only works on tables. If the table already has a protected metatable (has a `__metatable` field), this function errors.


### Protected Calls
```slua
function pcall(f: function, args: ...any): (boolean, ...any)
function xpcall(f: function, e: function, args: ...any): (boolean, ...any)
```
`pcall` calls function `f` with parameters `args`. If the function succeeds, returns `true` followed by all return values of `f`. If the function raises an error, returns `false` followed by the error object. Note that `f` can yield, which results in the entire coroutine yielding as well.

`xpcall` calls function `f` with parameters `args`. If the function succeeds, returns `true` followed by all return values of `f`. If the function raises an error, calls `e` with the error object as an argument, and returns `false` followed by the first return value of `e`. Note that `f` can yield, which results in the entire coroutine yielding as well. `e` can neither yield nor error - if it does raise an error, `xpcall` returns with `false` followed by a special error message.


### Userdata Creation
```slua
function newproxy(mt: boolean?): userdata
```
Creates a new untyped userdata object; when `mt` is true, the new object has an empty metatable that can be modified using `getmetatable`.


### Raw Access
```slua
function rawget<K, V>(t: { [K]: V }, k: K): V?
function rawset<K, V>(t: { [K] : V }, k: K, v: V)
function rawlen<K, V>(t: { [K]: V } | string): number
```
These functions provide raw access, bypassing the `__index`, `__newindex` and `__len` metamethods.

---

```slua
function rawequal(a: any, b: any): boolean
```
Returns `true` if `a` and `b` have the same type and point to the same object (for garbage collected types) or are equal (for value types).


### Iteration and Selection
```slua
function next<K, V>(t: { [K]: V }, i: K?): (K, V)?
```
Given the table `t`, returns the next key-value pair after `i` in the table traversal order, or nothing if `i` is the last key. When `i` is `nil`, returns the first key-value pair instead.

---

```slua
function select<T>(i: string, args: ...T): number
function select<T>(i: number, args: ...T): ...T
```
When called with `'#'` as the first argument, returns the number of remaining parameters passed. Otherwise, returns the subset of parameters starting with the specified index. Index can be specified from the start of the arguments (using `1` as the first argument), or from the end (using `-1` as the last argument).

---

```slua
function ipairs(t: table): <iterator>
```
Returns the triple (generator, state, `nil`) that can be used to traverse the table using a `for` loop. The traversal results in key-value pairs for the numeric portion of the table; key starts from 1 and increases by 1 on each iteration. The traversal terminates when reaching the first `nil` value (so `ipairs` can’t be used to traverse array-like tables with holes).

---

```slua
function pairs(t: table): <iterator>
```
Returns the triple (generator, state, `nil`) that can be used to traverse the table using a `for` loop. The traversal results in key-value pairs for all keys in the table, numeric and otherwise, but doesn’t have a defined order.

---

```slua
function unpack<V>(a: {V}, f: number?, t: number?): ...V
```
Returns all values of `a` with indices in `[f..t]` range. `f` defaults to 1 and `t` defaults to `#a`. Note that this is equivalent to `table.unpack`.


### Module loading for bundlers
```slua
function dangerouslyexecuterequiredmodule(f: (...any) -> ...any): ...any
```
This is a function added in SLua that allows module bundlers to load modules, helping with scoping and isolating module code. The function passed in is isolated like a module and returns the exports of the module. However mind that you will need to cache the results to avoid re-executing the module code on each call.

---

<Attribution
	title="Luau Library Documentation"
	source="https://luau.org/library"
	author="2019-2025 Roblox Corporation, 1994–2019 Lua.org, PUC-Rio"
	license="MIT"
/>
